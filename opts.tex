\section{Discussion and Conclusion}
\label{sec:opts}

The current state of the field of storage systems is clearly in the midst of significant
change. The sparse collection of guide posts capable of assisting developers navigating such a
large, complex, and ever-evolving physical design space serves as the primary source of 
motivation for the use of declarative languages as a novel method distancing 
the dynamic nature of storage systems from the more static nature of higher-level
applications. While our implementation does not yet map a declarative specification 
on to a particular physical design, the specification provides a powerful infrastructure for
automating such a mapping and achieving other optimizations.

Given the declarative flavor of the interfaces we have defined, 
deep parallels exist between the physical design challenges described in this paper and
the larger body of mature work in query planning and optimization. The Bloom
language used as a basis for the declarative specification language of our approach
produces a dataflow graph amenable to sophisticated static analyses. We
envision the graph will be made fully available for exploitation by the storage system.

We are currently considering the scope of optimizations possible with
such a dataflow model in the context of storage systems. For instance, without
semantic knowledge of the interface, batching techniques described in
Section~\ref{sec:batch} are limited to optimizations such as selecting magic
values for timers and buffer sizes. Semantic information expands the design
space and permits intelligent reordering or coalescing with a dependence upon the
relationship between operations beyond what auto-tuning has considered in a storage system context.

{\bf Conclusion.} With each new application-specific storage interface, one
must consider a future in which little to no
distinction exists between storage and database systems, or not. The roads to both alternative scenarios
are lined by intermediate solutions, such as the one we have proposed here, which 
explore tools and techniques for managing the dual tradeoffs of simplicity and portability.

%Looking beyond standard forms of optimization decisions that seek to select
%an appropriate mix of low-level I/O interfaces, data structure selection is an
%important point of optimization. For instance in Section~\ref{sec:dspace} we
%showed that using the bytestream for metadata management as opposed to the
%key-value interface offered superior performance. However the unstructured
%nature of the bytestream data model imposes no restrictions on implementation
%or storage layout. Integration of common indexing techniques into an optimizer
%combined with a performance model will allow our CORFU interface to derive
%similar optimizations when appropriate. Similar degrees of freedom can be
%imagined when handling other approaches to implementing the CORFU sequencer
%service. Given its soft-state nature heavy-weight processes that enforce
%durability can be circumvented in favor of shorter code paths that optimize
%for throughput and latency.
%
%
%For
%example today object classes are represented as black boxes from the point of
%view of the OSD execution engine.  Understanding the behavior of an object
%class may allow intelligent prefetching. Another type of analysis that may be
%useful for optimization is optimistic execution combined with branch
%prediction where frequent paths through a dataflow are handled optimistically.
